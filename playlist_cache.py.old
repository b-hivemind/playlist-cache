from datetime import datetime
import sys 
import time
import os
import json

from auth import login
from masterlib import _paged_results, generic_menu, log
from scopes import ALL_PLAYLIST_MODIFY_SCOPES, ALL_PLAYLIST_READ_SCOPES, RECENTLY_PLAYED_SCOPE, TOP_READ_SCOPE

REPEAT_REWIND_PLAYLIST_ID = "##"

INTERVAL = 60 * 60 * 1  # 1 hour
CONFIG_FILE_NAME = "config.json"

sp = login(" ".join([ALL_PLAYLIST_MODIFY_SCOPES, ALL_PLAYLIST_READ_SCOPES, RECENTLY_PLAYED_SCOPE, TOP_READ_SCOPE]))

def read_config():
    json_config = None
    with open(CONFIG_FILE_NAME, 'r') as readfile:
        json_config = json.load(readfile)
    return json_config

def write_config(cfg):
    with open(CONFIG_FILE_NAME, 'w') as outfile:
        outfile.write(cfg)

# [IDEA] might be interesting to explore storing and loading parent-cache pairs

# TODO Follow this to convert to class
""" def log_comparison_to_parent(self, playlist_track_ids, playlist_name=None):
    log(f"Common tracks {[self.client.track(track_id)['name'] for track_id in playlist_track_ids.intersection(parent_track_ids)]}")
    log(f"Exclusive to {playlist_name or 'playlist'} {[self.client.track(track_id)['name'] for track_id in (playlist_track_ids - parent_track_ids)]}")
    log(f"Exclusive to {parent_name or 'parent'} {[self.client.track(track_id)['name'] for track_id in (parent_track_ids - playlist_track_ids)]}")
 """
def get_repeat_rewind(sp):
    repeat_rewind_track_ids = set(x['track']['id'] for x in _paged_results(sp, sp.playlist_tracks(REPEAT_REWIND_PLAYLIST_ID)))
    log(f"Found {len(repeat_rewind_track_ids)} repeat rewind tracks")
    # log_comparison_to_parent(sp, repeat_rewind_track_ids)
    return repeat_rewind_track_ids

def get_top_tracks(sp, long=False):
    short_top_tracks = set([track['name'] for track in _paged_results(sp, sp.current_user_top_tracks(time_range='short_term'))])
    log(f"Found {len(short_top_tracks)} short term top tracks")
    med_top_tracks = set([track['name'] for track in _paged_results(sp, sp.current_user_top_tracks(time_range='medium_term'))])
    log(f"Found {len(med_top_tracks)} medium term top tracks")
    top_tracks_union = short_top_tracks.union(med_top_tracks)
    if long:
        log("Retrieving long term top tracks...")
        long_top_tracks = set([track['name'] for track in _paged_results(sp, sp.current_user_top_tracks(time_range='long_term'))])
        log(f"Found {len(long_top_tracks)} long term top tracks")
        top_tracks_union = top_tracks_union.union(long_top_tracks)
    log(f"Top tracks union contains {len(top_tracks_union)} tracks")
    # log_comparison_to_parent(sp, top_tracks_union)
    return top_tracks_union

def get_recents(sp):
    recently_played_track_ids = set([x['track']['id'] for x in _paged_results(sp, sp.current_user_recently_played())])
    log(f"Found {len(recently_played_track_ids)} recently played tracks")
    # log_comparison_to_parent(sp, recently_played_track_ids)
    return recently_played_track_ids

def fetch_user_common_tracks(sp, cnf):
    top_tracks = get_top_tracks(sp, long=cnf.get(long_term_top_tracks, False))
    recently_played = get_recents(sp)
    common_tracks = top_tracks.union(recently_played)
    if cnf.get(REPEAT_REWIND_PLAYLIST_ID):
        return common_tracks.union(get_repeat_rewind(sp))
    return common_tracks

def monitor(sp, cache_playlist_id, parent_playlist_id):
    parent_track_ids = set([x['track']['id'] for x in _paged_results(sp, sp.playlist_tracks(parent_playlist_id))])
    cache_track_ids = set([x['track']['id'] for x in _paged_results(sp, sp.playlist_tracks(cache_playlist_id))])
    
    cnf = read_config()
    
    most_played_track_ids = fetch_user_common_tracks(sp, cnf)
    
    common_tracks = parent_track_ids.intersection(most_played_track_ids)
    log("Common tracks {}".format(common_tracks))
    new_tracks = common_tracks - cache_track_ids
    log("Unique tracks {}".format(new_tracks))
    
    # If no common tracks are found, maintain the same state (don't delete tracks)
    if common_tracks != set():
        log(f"Adding tracks {[sp.track(x)['name'] for x in new_tracks]}")
        sp.playlist_add_items(cache_playlist_id, new_tracks)   
        # Delete tracks no longer commonly played if more tracks than required
        extras = cache_track_ids - common_tracks
        tracks_to_remove = []
        if len(cache_track_ids) > cnf.get(minlen, 0):    
            while len(cache_track_ids - extras) > cnf.get(minlen, 0):
                tracks_to_remove.append(extras.pop(0))
        log(f"Removing tracks {[sp.track(i)['name'] for i in tracks_to_remove]}")
        sp.playlist_remove_all_occurrences_of_items(cache_playlist_id, tracks_to_remove)
    else:
        log("No new tracks found")

parent_playlist_id = os.getenv('PARENT_PLAYLIST_ID')
cache_playlist_id = os.getenv('CACHE_PLAYLIST_ID')

if not parent_playlist_id:
    all_playlists = _paged_results(sp, sp.current_user_playlists())
    parent_playlist = generic_menu(all_playlists, title="Choose playlist to cache")
    if not parent_playlist:
        print("No playlist chosen")
        sys.exit(-1)
    parent_playlist_id = parent_playlist.get("id", parent_playlist.get("uri", "None"))
else:
    parent_playlist = sp.playlist(parent_playlist_id)
if not parent_playlist:
    log(f"Error: Invalid playlist {parent_playlist_id}")
    sys.exit(-1)
CACHE_PLAYLIST_NAME = f"{parent_playlist.get('name')} Cache"
CACHE_PLAYLIST_DESC = "This playlist is maintained by my playlist_cache script which runs an hourly job to compare my most \
    recently played music with the songs in {} and maintain this playlist with any matching tracks. Currently testing".format(parent_playlist.get('name'))

if not cache_playlist_id:
    # Create new cache playlist
    cache_playlist_id = sp.user_playlist_create(sp.me()['id'], name=CACHE_PLAYLIST_NAME, description=CACHE_PLAYLIST_DESC).get('id')
    log(f"Successfully created playlist {cache_playlist_id}")
while True:
    monitor(sp, cache_playlist_id, parent_playlist_id)
    log(f"Sleeping for {INTERVAL}")
    time.sleep(INTERVAL)



